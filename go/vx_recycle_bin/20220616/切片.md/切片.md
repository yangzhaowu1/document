# 切片
通过切片创建切片时可通过限制容量保证创建新的切片
#### 3、切片

切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片**赋值和函数传参数**时也是将切片**头信息部分按传值方式处理**。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制

切片高效操作的要点是要降低内存分配的次数，尽量保证`append`操作不会超出`cap`的容量，降低触发内存分配的次数和每次分配内存大小。

切片中的底层数组部分是通过隐式指针传递(指针本身依然是传值的，但是指针指向的却是同一份的数据)，所以被调用函数是可以通过指针修改掉调用参数切片中的数据。除了数据之外，切片结构还包含了切片长度和切片容量信息，这2个信息也是传值的。如果被调用函数中修改了`Len`或`Cap`信息的话，就无法反映到调用参数的切片中，这时候我们一般会通过返回修改后的切片来更新之前的切片。这也是为何内置的`append`必须要返回一个切片的原因。

append函数增长策略复杂，不能确定一次append是否会重新分配内存

通过slice实现栈

```go
stack = append(stack, v) //push
top = stack[len(stack)-1] //top
stack = stack[:len(stack)-1] //pop
```
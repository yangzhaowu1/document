# 常见数据结构
## 数组
* 组成：由相同类型元素的集合
* 存储：一块连续的内存，编译器决定是否应该在堆上
* 访问：索引快速访问，复杂的O(1)
* 类型：元素类型+最大容量构成数组类型
### 初始化
时间范围：数组的初始化是在编译期进行的，且在中间代码生成之前
```
//显示指定数组大小
arr1 := [3]int{1, 2, 3}

//编译器通过源代码推导数组大小，与显式指定在运行期的结果一致
arr2 := [...]int{1, 2, 3}
```

字面量组成数组的初始化
* 当元素数量小于或者等于4个时，会直接将数组中的元素放置在栈上；
* 当元素数量大于4个时，会将数组中的元素放置到静态区，然后拷贝到栈上

数组和字符串的一些简单越界错误（常量访问下标）都会在编译期间发现

## slice
切片：动态数组，长度并不固定，可以向切片中追加元素，它会在容量不足时自动扩容
组成：
```
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```
* Data：是指向数组的指针，一片连续的内存空间，这片内存空间可以用于存储切片中的全部元素
* Len：是当前切片的长度；
* Cap 是当前切片的容量，即 Data 数组的大小
切片引入了一个抽象层，提供了对数组中部分连续片段的引用，可以在运行区间修改它的长度和范围。当切片底层的数组长度不足时就会触发扩容，切片指向的数组可能会发生变化，不过在上层看来切片是没有变化的，上层只需要与切片打交道不需要关心数组的变化
### 初始化
1、下标
2、字面量
3、make
* 切片的大小和容量是否足够小；
* 切片是否发生了逃逸，最终在堆上初始化
### 扩容
* 如果期望容量大于当前容量的两倍就会使用期望容量；
* 如果当前切片的长度小于 1024 就会将容量翻倍；
* 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；

### 拷贝
copy(a, b)
通过 runtime.memmove 将整块内存的内容拷贝到目标的内存区域中

### tips
* 通过切片创建切片时可通过限制容量保证创建新的切片
* 切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制
* 切片高效操作的要点是要降低内存分配的次数，尽量保证append操作不会超出cap的容量，降低触发内存分配的次数和每次分配内存大小
* 切片中的底层数组部分是通过隐式指针传递(指针本身依然是传值的，但是指针指向的却是同一份的数据)，所以被调用函数是可以通过指针修改掉调用参数切片中的数据。除了数据之外，切片结构还包含了切片长度和切片容量信息，这2个信息也是传值的。如果被调用函数中修改了Len或Cap信息的话，就无法反映到调用参数的切片中，这时候我们一般会通过返回修改后的切片来更新之前的切片。这也是为何内置的append必须要返回一个切片的原因

通过slice实现栈
```
stack = append(stack, v) //push
top = stack[len(stack)-1] //top
stack = stack[:len(stack)-1] //pop
```

## map
O(1)的读写性能
### 哈希函数
目标：结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题；结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能
### 冲突解决
#### 开放寻址法
底层的数据结构：数组
核心思想：依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中
装载因子：数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 O(n) 
#### 拉链法
实现：数组+链表
具体过程：hash取模找桶，然后遍历桶地链表：
* 找到键相同的键值对，则更新键对应的值；
* 没有找到键相同的键值对；在链表的末尾追加新的键值对
装载因子：元素数量÷桶数量；在一般情况下装载因子都不会超过 1，当哈希表的装载因子较大时会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降
### 数据结构
```type hmap struct {
	count     int
	flags     uint8
	B         uint8
	noverflow uint16
	hash0     uint32

	buckets    unsafe.Pointer
	oldbuckets unsafe.Pointer
	nevacuate  uintptr

	extra *mapextra
}

type mapextra struct {
	overflow    *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```
* count 表示当前哈希表中的元素数量；
* B 表示当前哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 len(buckets) == 2^B；
* hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；
* oldbuckets 是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；
* runtime.bmap：桶，在内存中是连续存储的；可以存储存储 8 个键值对；
* nextOverflow：当桶中存储的数据过多，单个桶已经装满时就会使用 extra.nextOverflow 中桶存储溢出的数据

bmap：存储了键的哈希的高 8 位（tophash），通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能
选择桶序号：哈希的最低几位

### make
1. 计算哈希占用的内存是否溢出或者超出能分配的最大值；
2. 调用 runtime.fastrand 获取一个随机的哈希种子；
3. 根据传入的 hint 计算出需要的最小需要的桶的数量；
4. 使用 runtime.makeBucketArray 创建用于保存桶的数组
* 当桶的数量小于 16 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；
* 当桶的数量多于 16 时，会额外创建2的（B-4）次方个溢出桶

### 写入
1. 根据传入的键拿到对应的哈希和桶
2. 通过遍历比较桶中存储的 tophash 和键的哈希，如果找到了相同结果就会返回目标位置的地址

### 扩容
扩容原因：
* 装载因子已经超过 6.5；
* 哈希使用了太多溢出桶
扩容方式：
* 溢出的桶太多导致的扩容是等量扩容 sameSizeGrow
* 

sameSizeGrow ：通过复用已有的哈希扩容机制解决该问题，一旦哈希中出现了过多的溢出桶，它会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存

## string
存储：一片连续的只读的内存空间，可以看作一个由字符组成的数组

修改方式：
1. 先将这段内存拷贝到堆或者栈上；
2. 将变量的类型转换成 []byte 后并修改字节数据；
3. 将修改后的字节数组转换回 string

### 数据结构
```
type StringHeader struct {
	Data uintptr
	Len  int
}
```

声明：
双引号：单行字符串的初始化,内部出现双引号，需要使用 \ 符号避免编译器的解析错误
```
str1 := "this is a string"

```
go语言处理逻辑
* 使用双引号表示开头和结尾；
* 需要使用反斜杠 \ 来逃逸双引号；
* 不能出现如下所示的隐式换行 \n；
反引号：反引号声明的字符串可以摆脱单行的限制。当使用反引号时，因为双引号不再负责标记字符串的开始和结束，我们可以在字符串内部直接使用 "
```
str2 := `this is another
string`

json := `{"author": "draven", "tags": ["golang"]}`
```
### 拼接
运行时会调用 copy 将输入的多个字符串拷贝到目标字符串所在的内存空间。新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失是无法忽略的
### 类型转换
Go 语言解析和序列化 JSON 等数据格式时，经常需要将数据在 string 和 []byte 之间来回转换
字符串和 []byte对比
* 内容一样
* 字符串只读；[]byte可读写
* 无论从哪种类型转换到另一种都需要拷贝数据













## channel
channel主要用于进程内各goroutine间通信
src/runtime/chan.go:hchan定义了channel的数据结构：
```
type hchan struct {
    qcount   uint           // 当前队列中剩余元素个数
    dataqsiz uint           // 环形队列长度，即可以存放的元素个数
    buf      unsafe.Pointer // 环形队列指针
    elemsize uint16         // 每个元素的大小
    closed   uint32            // 标识关闭状态
    elemtype *_type         // 元素类型
    sendx    uint           // 队列下标，指示元素写入时存放到队列中的位置
    recvx    uint           // 队列下标，指示元素从队列的该位置读出
    recvq    waitq          // 等待读消息的goroutine队列
    sendq    waitq          // 等待写消息的goroutine队列
    lock mutex              // 互斥锁，chan不允许并发读写
}
```
* 环形队列作为缓冲区，队列的长度是创建chan时指定
* 从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞
* 向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞
* 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒
* 因写阻塞的goroutine会被从channel读数据的goroutine唤醒
● 给一个 nil channel 发送数据，造成永远阻塞 
●  从一个 nil channel 接收数据，造成永远阻塞 
●  给一个已经关闭的 channel 发送数据，引起 panic 
●  从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 
●  无缓冲的channel是同步的，而有缓冲的channel是非同步的 
口诀：空读写阻塞，写关闭异常，读关闭空零”


## struct
## iota

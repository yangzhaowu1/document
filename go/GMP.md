# GMP
## 一、GMP



把大量的goroutine分配到少量的线程上去执行，利用多核并行，实现更强大的并发。

### 1、G(goroutine)

受go运行时管理的轻量级线程，使用go关键字创建，main函数也是一个goroutine。

每个goroutine都有自己的栈空间，定时器，初始化的栈空间在2k左右，空间会随着需求增长。

goroutine的新建, 休眠, 恢复, 停止都受到go运行时的管理。

goroutine执行异步操作时会进入休眠状态, 待操作完成后再恢复, 无需占用系统线程。

goroutine新建或恢复时会添加到运行队列, 等待M取出并运行。

### 2、M(machine)

抽象化代表内核线程，记录内核线程栈信息，当goroutine调度到线程时，使用该goroutine自己的栈信息。

系统线程，可运行两种代码：

- go代码，即goroutine，需要一个P。
- 原生代码，如阻塞的syscall，不需要P。

M会从运行队列中取出G, 然后运行G, 如果G运行完毕或者进入休眠状态, 则从运行队列中取出下一个G运行, 周而复始.

有时候G需要调用一些无法避免阻塞的原生代码, 这时M会释放持有的P并进入阻塞状态, 其他M会取得这个P并继续运行队列中的G.

go需要保证有足够的M可以运行G, 不让CPU闲着, 也需要保证M的数量不能过多.

M的状态

- 自旋线程：处于运行但没有可执行goroutine的线程，数量上限为GOMAXPROC
- 非自旋线程：处于运行状态有可执行goroutine的线程

G的主要几种状态：

- **_Gidle**：刚刚被分配并且还没有被初始化，值为0，为创建goroutine后的默
- **_Grunnable**： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中(如上图)。
- **_Grunning**： 正在执行代码的goroutine，拥有栈的所有权(如上图)。
- **_Gsyscall**：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列(如上图)。
- **_Gwaiting**：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列(如上图)。
- *_Gdead**： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree，可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine(如上图)**_
- _Gcopystac**：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在**_
- __Gscan** ： GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在

### 3、P(process)

代表**调度器**，负责调度goroutine，维护一个本地goroutine队列，M从P上获得goroutine并执行，同时还负责部分内存的管理。

代表M运行G所需的资源，数量默认等于CPU核心数，可通过环境变量GOMAXPROC修改。

P的数量表示当前最多只有P个线程(M)执行Go代码，原生代码的线程数不受控制。

![preview](https://pic1.zhimg.com/v2-8e653b564583bdcc8dad669af16396c4_r.jpg)![]()

P的状态：

- **_Pidle** ：处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空
- **_Prunning** ：被线程 M 持有，并且正在执行用户代码或者调度器(如上图)
- **_Psyscall**：没有执行用户代码，当前线程陷入系统调用(如上图)
- **_Pgcstop** ：被线程 M 持有，当前处理器由于垃圾回收被停止
- **_Pdead** ：当前处理器已经不被使用
# 协程
## 进程、线程、协程对比
### 进程
* 可执行程序运行中形成一个独立的内存体
* 有自己独立的地址空间(Linux会给每个进程分配一个虚拟内存空间32位操作系统为4G, 64位为很多T)，有自己的堆，上级挂靠单位是操作系统
* 操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位
* 一个单独的执行单位，CPU分配时间片
* 占用内存：4G
### 线程
* 轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位
* 线程拥有独立的栈，但是共享进程的全部资源
* 系统内核调度的对象是线程，因为线程是调度的基本单元
*  单独的执行单位，CPU分配时间片，一个进程想更大程度的与其他进程抢占CPU的资源，那么多开线程
* 占用内存：线程跟不同的操作系统版本有有差异，基本都是维持Mb的量级单位，几兆
线程切换流程：

* 切换内核栈 
* 切换硬件上下文 
* 保存寄存器中的内容，将之前执行流程的状态保存
* CPU高速缓存失效，程序运行会变慢
### 协程
* 用户态的伪执行单元
* 体积轻量，优质的GMP调度
* 占用内存：几KB，随着协程需要不断扩容
切换流程：把当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上就 ok 了。而且完全在用户态进行，一般来说一次协程上下文切换最多就是几十ns 这个量级
与线程对比：
* 协程切换完全在用户空间进行；线程切换涉及特权模式切换，需要在内核空间完成
* 协程切换相比线程切换做的事情更少，线程需要有内核和用户态的切换,系统调用过程。

迅速的开辟goroutine(不控制并发的 goroutine 数量 )会在短时间内占据操作系统的资源(CPU、内存、文件描述符等
## 协程如何保活
* 子goroutine：给一个被监控的Goroutine添加一个defer ，然后recover() 捕获到当前Goroutine的异常状态，最后给主Goroutine发送一个死亡信号，通过Channel
* 主goroutine：从这个Channel读取内容，当读到内容时，就重启这个子Goroutine，当然主Goroutine需要记录子Goroutine的ID，这样也就可以针对性的启动了




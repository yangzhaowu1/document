# 垃圾回收
垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。
## 标记-清除算法
标记-清除(mark and sweep)算法主要是在Go1.3之前使用

具体步骤：
1. 暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记

2. 开始标记，程序找出它所有可达的对象，并做上标记
3. 标记完了之后，然后开始清除未标记的对象
4. 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束

缺点
* STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)

* 标记需要扫描整个heap
* 清除数据会产生heap碎片

## 三色并发标记法
三色并发标记法在Go1.5中使用，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)

具体步骤：
1. 新创建的对象，默认标记为“白色”

2. 每次GC开始, 从根节点开始遍历（一次遍历，非递归）所有对象，把遍历到的对象从白色集合放入“灰色”集合
3. 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
4. 重复第三步, 直到灰色中无任何对象
5. 回收所有的白色标记表的对象. 也就是回收垃圾

三色标记如果不STW可能出现错误回收

● 条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)

● 条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)
## 屏障机制
### 强三色不变式
不存在黑色对象引用到白色对象的指针
### 弱三色不变式
所有被黑色对象引用的白色对象都处于灰色保护状态
保护状态：黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象
### 插入屏障
具体操作：在A对象引用B对象的时候，B对象被标记为灰色
满足：强三色不变式
屏障技术是不在栈上应用的，因为要保证栈的运行效率
三色标记完成后，STW，再重新扫描一次栈空间，被引用的标记为黑色
### 删除屏障
具体操作：被删除引用的对象，如果自身为灰色或者白色，那么被标记为灰色
满足：弱三色不变式. (保护灰色对象到白色对象的路径不会断)
缺点：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉
## 混合写屏障机制
混合写屏障(hybrid write barrier)机制在GoV1.8使用

插入写屏障和删除写屏障的短板：

●  插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活

●  删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象
 
混合写屏障规则（满足变形的弱三色不变式.）
* GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)

* GC期间，任何在栈上创建的新对象，均为黑色
* 被删除的对象标记为灰色
* 被添加的对象标记为灰色
## 总结
* GoV1.3-普通标记清除法:整体过程STW，效率极低。

* GoV1.5- 三色标记法:堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通

* GoV1.8-三色标记法:混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。
# 并发编程
## context
context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体
```
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key interface{}) interface{}
}
```
* Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期；
* Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel；
* Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值；
    1. 如果 context.Context 被取消，会返回 Canceled 错误；
    2. 如果 context.Context 超时，会返回 DeadlineExceeded 错误；
* Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；

在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 context.Context 的最大作用
context 包中最常用的方法还是 context.Background、context.TODO，这两个方法都会返回预先初始化好的私有变量 background 和 todo，它们会在同一个 Go 程序中被复用
从源代码来看，context.Background 和 context.TODO 也只是互为别名，没有太大的差别，只是在使用和语义上稍有不同：
* context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；
* context.TODO 应该仅在不确定应该使用哪种上下文时使用
## sync
Go 语言在 sync 包中提供了用于同步的一些基本原语，包括常见的 sync.Mutex、sync.RWMutex、sync.WaitGroup、sync.Once 和 sync.Cond
### Mutex
Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成
```
type Mutex struct {
    //当前互斥锁的状态
	state int32
	//控制锁状态的信号量
	sema  uint32
}
```
#### state
互斥锁的状态比较复杂，如下图所示，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放
![Mutex state](vx_images/540785920220663.png)
在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态
* mutexLocked — 表示互斥锁的锁定状态；
* mutexWoken — 表示从正常模式被从唤醒；
* mutexStarving — 当前的互斥锁进入饥饿状态；
* waitersCount — 当前互斥锁上等待的 Goroutine 个数；
#### 正常模式和饥饿模式
* 正常模式：锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』
* 饥饿模式：目的是保证互斥锁的公平性；互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式

性能对比
* 正常模式下的互斥锁能够提供更好地性能
* 饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时

#### 加锁和解锁
##### 加锁
1. 判断当前 Goroutine 能否进入自旋；
2. 通过自旋等待互斥锁的释放；
3. 计算互斥锁的最新状态；
4. 更新（使用 CAS 函数）互斥锁的状态并获取锁；
自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻
* 互斥锁只有在普通模式才能进入自旋；
* runtime.sync_runtime_canSpin 需要返回 true：
* 运行在多 CPU 的机器上；
* 当前 Goroutine 为了获取该锁进入自旋的次数小于四次；
* 当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空
##### 解锁
在正常模式下，上述代码会使用如下所示的处理过程：
* 如果互斥锁不存在等待者或者互斥锁的 mutexLocked、mutexStarving、mutexWoken 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；
* 如果互斥锁存在等待者，会通过 sync.runtime_Semrelease 唤醒等待者并移交锁的所有权；
在饥饿模式下：直接调用 sync.runtime_Semrelease 将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；
##### 小结
互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：

* 如果互斥锁处于初始化状态，会通过置位 mutexLocked 加锁；
* 如果互斥锁处于 mutexLocked 状态并且在普通模式下工作，会进入自旋，执行 30 次 PAUSE 指令消耗 CPU 时间等待锁的释放；
* 如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；
* 互斥锁在正常情况下会通过 runtime.sync_runtime_SemacquireMutex 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；
* 如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；

互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰
* 当互斥锁已经被解锁时，调用 sync.Mutex.Unlock 会直接抛出异常；
当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位；
当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 sync.runtime_Semrelease 唤醒对应的 Goroutine
### RWMutex 
读写互斥锁 sync.RWMutex 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行
```
type RWMutex struct {
    //复用互斥锁提供的能力
	w           Mutex
	//写等待读
	writerSem   uint32
	//读等待写
	readerSem   uint32
	//当前正在执行的读操作数量
	readerCount int32
	//当写操作被阻塞时等待的读操作个数
	readerWait  int32
}
```
#### 写锁
加锁：
当资源的使用者想要获取写锁时，需要调用 sync.RWMutex.Lock 方法

1. 调用结构体持有的 sync.Mutex 结构体的 sync.Mutex.Lock 阻塞后续的写操作；，其他 Goroutine 在获取写锁时会进入自旋或者休眠；
2. 调用 sync/atomic.AddInt32 函数阻塞后续的读操作
3. 如果仍然有其他 Goroutine 持有互斥锁的读锁，该 Goroutine 会调用 runtime.sync_runtime_SemacquireMutex 进入休眠状态等待所有读锁所有者执行结束后释放 writerSem 信号量将当前协程唤醒
释放

* 调用 sync/atomic.AddInt32 函数将 readerCount 变回正数，释放读锁；
* 通过 for 循环释放所有因为获取读锁而陷入等待的 Goroutine：
* 调用 sync.Mutex.Unlock 释放写锁；

获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作[饿死]
#### 读锁
加锁： sync.RWMutex.RLock；会通过 sync/atomic.AddInt32 将 readerCount 加一

1. 如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 runtime.sync_runtime_SemacquireMutex 陷入休眠等待锁的释放；
2. 如果该方法的结果为非负数 ： 没有 Goroutine 获得写锁，当前方法会成功返回
释放：
会先减少正在读资源的 readerCount 整数，根据 sync/atomic.AddInt32 的返回值不同会分别进行处理：

1. 如果返回值大于等于零 ： 读锁直接解锁成功；
2. 如果返回值小于零 ： 有一个正在执行的写操作，在这时会调用sync.RWMutex.rUnlockSlow 方法

sync.RWMutex.rUnlockSlow 会减少获取锁的写操作等待的读操作数 readerWait 并在所有读操作都被释放之后触发写操作的信号量 writerSem，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine

#### 总结
1. 调用 sync.RWMutex.Lock 尝试获取写锁时；
    * 每次 sync.RWMutex.RUnlock 都会将 readerCount 其减一，当它归零时该 Goroutine 会获得写锁；
    * 将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作；
2. 调用 sync.RWMutex.Unlock 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；

读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能

### WaitGroup 
sync.WaitGroup 可以等待一组 Goroutine 的返回
```
type WaitGroup struct {
    //保证 sync.WaitGroup 不会被开发者通过再赋值的方式拷贝
	noCopy noCopy
	//存储着状态和信号量
	state1 [3]uint32
}
```
#### 接口
sync.WaitGroup.Add：更新 sync.WaitGroup 中的计数器 counter。虽然 sync.WaitGroup.Add 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃。当调用计数器归零，即所有任务都执行完成时，才会通过 sync.runtime_Semrelease 唤醒处于等待状态的 Goroutine
sync.WaitGroup.Wait：会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 runtime.sync_runtime_Semacquire 陷入睡眠;当 sync.WaitGroup 的计数器归零时，陷入睡眠状态的 Goroutine 会被唤醒，上述方法也会立刻返回
sync.WaitGroup.Done：只是向 sync.WaitGroup.Add 方法传入了 -1

#### 小结
* sync.WaitGroup 必须在 sync.WaitGroup.Wait 方法返回之后才能被重新使用；
* sync.WaitGroup.Done 只是对 sync.WaitGroup.Add 方法的简单封装，我们可以向 sync.WaitGroup.Add 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；
* 可以同时有多个 Goroutine 等待当前 sync.WaitGroup 计数器的归零，这些 Goroutine 会被同时唤醒

### Once
Go 语言标准库中 sync.Once 可以保证在 Go 程序运行期间的某段代码只会执行一次
```
type Once struct {
    //用于标识代码块是否执行过
	done uint32
	//互斥锁 sync.Mutex
	m    Mutex
}
```
sync.Once.Do 是 sync.Once 结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：

* 如果传入的函数已经执行过，会直接返回；
* 如果传入的函数没有执行过，会调用 sync.Once.doSlow 执行传入的函数

### Cond
Go 语言标准库中还包含条件变量 sync.Cond，它可以让一组的 Goroutine 都在满足特定条件时被唤醒。每一个 sync.Cond 结构体在初始化时都需要传入一个互斥锁
```
type Cond struct {
    //保证结构体不会在编译期间拷贝
	noCopy  noCopy
	//保护内部的 notify 字段
	L       Locker
	// 一个 Goroutine 的链表，它是实现同步机制的核心结构
	notify  notifyList
	//禁止运行期间发生的拷贝
	checker copyChecker
}

type notifyList struct {
    //当前正在等待的Goroutine 的索引
	wait uint32
	//当前已经通知到的 Goroutine 的索引
	notify uint32

	lock mutex
	//指向的链表的头
	head *sudog
	//指向的链表的尾
	tail *sudog
}
```
sync.Cond.Wait 方法会将当前 Goroutine 陷入休眠状态
* 调用 runtime.notifyListAdd 将等待计数器加一并解锁；
* 调用 runtime.notifyListWait 等待其他 Goroutine 的唤醒并加锁

sync.Cond.Signal 和 sync.Cond.Broadcast 就是用来唤醒陷入休眠的 Goroutine 的方法
* sync.Cond.Signal 方法会唤醒队列最前面的 Goroutine；
* sync.Cond.Broadcast 方法会唤醒队列中全部的 Goroutine

sync.Cond 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 for {} 进行忙碌等待相比，sync.Cond 能够让出处理器的使用权，提高 CPU 的利用率。使用时我们也需要注意以下问题：

* sync.Cond.Wait 在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；
* sync.Cond.Signal 唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；
* sync.Cond.Broadcast 会按照一定顺序广播通知等待的全部 Goroutine
## timer
* Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护: 全局唯一的互斥锁，这会严重影响计时器的性能
* Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护: 能够降低锁的粒度，提高计时器的性能;处理器和线程之间频繁的上下文切换却成为了影响计时器性能的首要因素
* Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发

目前计时器都交由处理器的网络轮询器和调度器触发，这种方式能够充分利用本地性、减少上下文的切换开销，也是目前性能最好的实现方式
## channel
不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存
通信顺序进程（Communicating sequential processes，CSP）。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据
### 先入先出
* 先从 Channel 读取数据的 Goroutine 会先接收到数据；
* 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利
### 无锁管道
* 同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方；
* 异步 Channel — 基于环形缓存的传统生产者消费者模型；
* chan struct{} 类型的异步 Channel : struct{} 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义
### 数据结构
```
type hchan struct {
    //Channel 中的元素个数
	qcount   uint
	
	//Channel 中的循环队列的长度
	dataqsiz uint
	
	// Channel 的缓冲区数据指针
	buf      unsafe.Pointer
	
	//当前 Channel 能够收发的元素大小
	elemsize uint16
	
	closed   uint32
	
	//当前 Channel 能够收发的元素类型
	elemtype *_type
	
	//Channel 的发送操作处理到的位置
	sendx    uint
	
	//Channel 的接收操作处理到的位置
	recvx    uint
	
	//当前 Channel 由于缓冲区空间不足而阻塞的 读Goroutine 列表
	recvq    waitq
	
    ////当前 Channel 由于缓冲区空间不足而阻塞的 写Goroutine 列表
	sendq    waitq

	lock mutex
}
```
### 初始化
* 如果当前 Channel 中不存在缓冲区，那么就只会为 runtime.hchan 分配一段内存空间；
* 如果当前 Channel 中存储的类型不是指针类型，会为当前的 Channel 和底层的数组分配一块连续的内存空间；
* 在默认情况下会单独为 runtime.hchan 和缓冲区分配内存

### 发送数据
* 如果 Channel 已经关闭，那么向该 Channel 发送数据时会报 “send on closed channel” 错误并中止程序
* 当存在等待的接收者时，通过 runtime.send 直接将数据发送给阻塞的接收者：从接收队列 recvq 中取出最先陷入等待的 Goroutine 并直接向它发送数据
* 当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；
* 当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据

* 如果当前 Channel 的 recvq 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；
* 如果 Channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 sendx 所在的位置上；
* 如果不满足上面的两种情况，会创建一个 runtime.sudog 结构并将其加入 Channel 的 sendq 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；

发送数据的过程中包含几个会触发 Goroutine 调度的时机：

* 发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 runnext 属性，但是并不会立刻触发调度；
* 发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 Channel 的 sendq 队列并调用 runtime.goparkunlock 触发 Goroutine 的调度让出处理器的使用权
### 接收数据
* 当我们从一个空 Channel 接收数据时会直接调用 runtime.gopark 让出处理器的使用权
* 如果当前 Channel 已经被关闭并且缓冲区中不存在任何数据，那么会清除 ep 指针中的数据并立刻返回
* 当存在等待的发送者时，通过 runtime.recv 从阻塞的发送者或者缓冲区中获取数据；
* 当缓冲区存在数据时，从 Channel 的缓冲区中接收数据；
* 当缓冲区中不存在数据时，等待其他 Goroutine 向 Channel 发送数据

从 Channel 中接收数据时可能会发生的五种情况

* 如果 Channel 为空，那么会直接调用 runtime.gopark 挂起当前 Goroutine；
* 如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 会直接返回；
* 如果 Channel 的 sendq 队列中存在挂起的 Goroutine，会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；
* 如果 Channel 的缓冲区中包含数据，那么直接读取 recvx 索引对应的数据；
* 在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；
* 
我们总结一下从 Channel 接收数据时，会触发 Goroutine 调度的两个时机：

* 当 Channel 为空时；
* 当缓冲区中不存在数据并且也不存在数据的发送者时

### 关闭channel
当 Channel 是一个空指针或者已经被关闭时，Go 语言运行时都会直接崩溃并抛出异常

### 网络轮询器
### 系统监控


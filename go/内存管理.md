# 内存管理
目的：在多线程下编程下，追求更高的内存管理效率，更快的分配是主要目的
如何更快地分配内存？
* 引入虚拟内存，将内存访问的进程级并发降低到线程级并发
## 不同语言的内存分配
1. C/C++: 主动申请、主动释放
2. Go：逃逸分析和GC，将开发者从内存管理中释放出来，让开发者有更多的精力去关注软件设计，而不是底层的内存问题
## TCMalloc
Thread Cache Malloc，Go内存管理的起源，主要的思想、原理、概念一致
### 主要思想
为每一个线程预分配一块缓存，线程申请小内存时，可以直接从缓存分配
1. 一次系统调用预分配缓存，后续线程小内存申请直接在用户态执行；缩短了内存总体的分配和释放时间
2. 多个线程并发申请小内存时，从各自缓存分配，访问不同地址空间，无需加锁，降低内存访问的并发力度
### 原理
![TcMalloc原理图](vx_images/144622722247568.svg =1000x)

1. Page：内存管理单位，大小为8KB，与操作系统页（一般为4KB）大小呈倍数关系
2. Span：一组连续的Page，TcMalloc的内存管理基本单元
3. ThreadCache：每个线程各自缓存（无锁访问），一个cache包含多个空闲内存块链表，同一个链表上内存块大小一样（方便快速分配内存块）
4. CentralCache：所有线程共享的缓存（加锁访问），保存空闲内存块链表，链表数量与ThreadCache中链表数量相同，ThreadCache中内存块不足时从中心cache中取，周期性地将ThreadCache中过多的内存块放回中心cache
5. PageHeap：堆内存抽象，存储若干链表，链表保存Span(加锁访问)；中心cache缺内存时从PageHeap取，把一个Span拆分成若干内存块，添加到对应大小的链表中，中心cache内存多的时候又放回PageHeap
### 内存分配流程
1. 小对象的分配流程：ThreadCache -> CentralCache -> HeapPage
2. 中对象分配流程：直接在PageHeap中选择适当的大小即可，128 Page的Span所保存的最大内存就是1MB。
3. 大对象分配流程：从large span set选择合适数量的页面组成span，用来存储数据。自旋锁
## Go内存管理
![Go内存管理](vx_images/467402323245070.png =1300x)
1. Page：X64下一个page大小为8KB
2. Span：内存管理的基本单元，代码中为mspan，一组连续的page组成一个span
3. mcache：与TcMalloc类似，保存各种大小的span，并按照span class分类，小对象直接从mcache分配，起到缓存作用，并实现无锁访问
* TcMalloc中每个线程一个ThreadCache，Go中每个P一个mcache。因为在Go程序中，当前最多有GOMAXPROCS个线程在用户态运行，所以最多需要GOMAXPROCS个mcache就可以保证各线程对mcache的无锁访问，线程的运行又是与P绑定的，把mcache交给P刚刚好。
4. mcentral：所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。
* CentralCache是每个级别的Span有1个链表，mcache是每个级别的Span有2个链表，这和mcache申请内存有关
5. mheap：与TCMalloc中的PageHeap类似，它是堆内存的抽象，把从OS申请出的内存页组织成Span，并保存起来，当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。
* mheap把Span组织成了树结构，而不是链表，并且还是2棵树，然后把Span分配到heapArena进行管理，它包含地址映射和span是否包含指针等位图，这样做的主要原因是为了更高效的利用内存：分配、回收和再利用。
### 大小转换
![Go内存大小转换](vx_images/273383823226311.png =395x)
1. object size：代码里简称size，指申请内存的对象大小。
2. size class：代码里简称class，它是size的级别，相当于把size归类到一定大小的区间段，比如size[1,8]属于size class 1，size(8,16]属于size class 2。
3. span class：指span的级别，但span class的大小与span的大小并没有正比关系。span class主要用来和size class做对应，1个size class对应2个span class，2个span class的span大小相同，只是功能不同，1个用来存放包含指针的对象，一个用来存放不包含指针的对象，不包含指针对象的Span就无需GC扫描了。
4. num of page：代码里简称npage，代表Page的数量，其实就是Span包含的页数，用来分配内存
### 内存分配
![Go内存对象分类](vx_images/122854323248751.png =479x)
小对象是在mcache中分配的，而大对象是直接从mheap分配的
#### 小对象分配
##### 为对象寻找span
1. 计算对象所需内存大小size
2. 根据size到size class映射，计算出所需的size class
3. 根据size class和对象是否包含指针计算出span class
4. 获取该span class指向的span。
##### 从span分配对象空间
Span可以按对象大小切成很多份，这些都可以从映射表上计算出来，以size class 3对应的span为例，span大小是8KB，每个对象实际所占空间为32Byte，这个span就被分成了256块，可以根据span的起始地址计算出每个对象块的内存地址。
当分配内存时，只要快速找到第一个可用的绿色块，并计算出内存地址即可，如果需要还可以对内存块数据清零。
##### span没有空间怎么分配对象
span内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache会向mcentral申请1个span，mcache拿到span后继续分配对象。
##### mcentral向mcache提供span
mcache向mcentral要span时，mcentral会先从nonempty搜索满足条件的span，如果没有找到再从emtpy搜索满足条件的span，然后把找到的span交给mcache。
mheap的span管理
mheap里保存了2棵二叉排序树，按span的page数量进行排序：
1. free：free中保存的span是空闲并且非垃圾回收的span。
2. scav：scav中保存的是空闲并且已经垃圾回收的span。
mheap中还有arenas，有一组heapArena组成，每一个heapArena都包含了连续的pagesPerArena个span，这个主要是为mheap管理span和垃圾回收服务。

mheap本身是一个全局变量，它其中的数据，也都是从OS直接申请来的内存，并不在mheap所管理的那部分内存内。
##### mcentral向mheap要span
mcentral向mcache提供span时，如果emtpy里也没有符合条件的span，mcentral会向mheap申请span。
mcentral需要向mheap提供需要的内存页数和span class级别，然后它优先从free中搜索可用的span，如果没有找到，会从scav中搜索可用的span，如果还没有找到，它会向OS申请内存，再重新搜索2棵树，必然能找到span。如果找到的span比需求的span大，则把span进行分割成2个span，其中1个刚好是需求大小，把剩下的span再加入到free中去，然后设置需求span的基本信息，然后交给mcentral。
##### mheap向OS申请内存
当mheap没有足够的内存时，mheap会向OS申请内存，把申请的内存页保存到span，然后把span插入到free树 。

在32位系统上，mheap还会预留一部分空间，当mheap没有空间时，先从预留空间申请，如果预留空间内存也没有了，才向OS申请。
#### 大对象分配
大对象的分配比小对象省事多了，99%的流程与mcentral向mheap申请内存的相同，所以不重复介绍了，不同的一点在于mheap会记录一点大对象的统计信息，见mheap.alloc_m()。
### 垃圾回收与内存释放
Go使用垃圾回收收集不再使用的span，调用mspan.scavenge()把span释放给OS（并非真释放，只是告诉OS这片内存的信息无用了，如果你需要的话，收回去好了），然后交给mheap，mheap对span进行span的合并，把合并后的span加入scav树中，等待再分配内存时，由mheap进行内存再分配

## 栈
每个goroutine都有自己的栈，栈的初始大小是2KB，100万的goroutine会占用2G，但goroutine的栈会在2KB不够用时自动扩容，当扩容为4KB的时候，百万goroutine会占用4GB。
## 总结
1. 使用缓存提高效率：一是减少了系统调用的次数，二是降低了锁的粒度，减少加锁的次数，从这2点提高了内存管理效率。
2. 以空间换时间，提高内存管理效率
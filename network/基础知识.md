# 基础知识
##定义
- 网络:是由若干节点和连接这些节点的链路构成，表示诸多对象及其相互联系。

- 计算机网络:通俗地讲就是通过传输介质将分布在各个地方的计算机和网络设备连接起来，实现数据通信、资源共享的一张网络。

- 计算机网络主要包括三部分：

    1、计算机 （可以包括客户端、服务器）

    2、网络设备 （路由器、交换机、防火墙等）

    3、传输介质（可以分为有线和无线的）

##协议
- 网络中不同的协议定义了不同的网络数据转发规则。

###OSI七层参考模型

- OSI（Open System Interconnect），即开放式系统互联参考模型，该体系结构标准定义了网络互联的七层框架

    （1）每一层的功能都以协议形式描述，不同主机之间的相同层次被称为对等层

    （2）OSI模型中每一层是隔离的，同时又是有联系的

    （3）OSI模型中每一层向相邻上层提供一套确定的服务
    
####1、物理层

- 定义了系统的电气、机械、过程和功能标准
- 基本单位：比特流，即0和1

####2、数据链路层

- 基本单位：帧
- 链路层地址（以太网使用MAC地址）来访问介质
- 为网络层提供差错控制和流量控制服务
- 数据链路层由MAC(介质访问控制子层)和LLC(逻辑链路控制子层)组成。

    （1）MAC：规定如何在物理线路上传输帧（和物理层相连）

    （2）LLC：逻辑上识别不同协议类型，并对其进行封装（和网络层对接）


####3、网络层

- 传基本单位：数据包
- 提供IP地址，负责把数据包从源网络传输到目标网络的路由选择工作。

####4、传输层

- 传基本单位：段
- 提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。

####5、会话层
    
- 负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。    
    
####6、表示层

- 提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。

####7、应用层
 
 - 为应用程序提供网络服务。   
 
 
###TCP/IP模型

分层优点
- 可使各层之间互相独立
- 灵活性好
- 各层可以采用最合适的技术来实现
- 易于实现和维护
- 能促进标准化工作

## 一、网络探测收包

### 1、socket方法:

```go
netAddr, _ := net.ResolveIPAddr("ip4", localAddress)
conn, err := net.ListenIP("ip4:tcp", netAddr)

buf := make([]byte, 64)
for {
    buf = make([]byte, 64)
		numRead, rAddr, err := conn.ReadFrom(buf)
		if err != nil {
			continue
		}
    
    //handle packet
}
```

**缺点**：从内核态将所有报文拷贝到用户态，性能随着服务器流量增加而迅速变差

### 2、libpcap

```go
handle, _ := pcap.OpenLive("any", 100, false, pcap.BlockForever * 100)
defer handle.Close()
//filter:过滤条件，其配置方法同tcpdump类似
//icmp[icmptype] = icmp-echoreply or ((tcp[tcpflags] & tcp-syn) != 0 and src portrange 61248-61343)
if err := handle.SetBPFFilter(filter); err != nil {
    log.Error("set BPF filter failed: ", err)
    return
}

src := gopacket.NewPacketSource(handle, handle.LinkType())
src.NoCopy = true
src.Lazy = true

for {
    packet, err := src.NextPacket()
    if err != nil || len(packet.Layers()) > 4 {
        continue
    }
    
    //handle packet
}
```

**优点**：在内核中过滤数据报文，减少内核态到用户态的拷贝，性能几乎不受服务器流量影响

### 3、ebpf

利用kprobe、Socket_Filter、XDP在内核直接抓取报文，并经由map与用户态交互

优点：

（1）通过在内核中拿到完整skb信息，数据过滤更加精准

（2）共享map的使用避免内核态到用户态的数据拷贝

（3）可以直接在内核态完成统计，如ping包回包数

## 二、网络知识tips

**1、在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？**

（1）第一个原因是当数据发送完成以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收，还是对于发送完毕，触发的软中断都是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。

（2）第二个原因是对于读来说，都是要经过 NET_RX 软中断的，都走 ksoftirqd 内核进程。而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出 NET_TX，让软中断上。

**3.我们在监控内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？**

（1）在网络包的发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的事情都干了。只有当内核态进程被切走前才会发起软中断。发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。

（2）只有一少部分情况下才会触发软中断（NET_TX 类型），由软中断 ksoftirqd 内核进程来发送。

所以，在监控网络 IO 对服务器造成的 CPU 开销的时候，不能仅仅只看 si，而是应该把 si、sy 都考虑进来。

**3.发送网络数据的时候都涉及到哪些内存拷贝操作？**

这里的内存拷贝，我们只特指待发送数据的内存拷贝。

（1）第一次拷贝操作是内核申请完 skb 之后，这时候会将用户传递进来的 buffer 里的数据内容都拷贝到 skb 中。如果要发送的数据量比较大的话，这个拷贝操作开销还是不小的。

（2）第二次拷贝操作是从传输层进入网络层的时候，每一个 skb 都会被克隆一个新的副本出来。网络层以及下面的驱动、软中断等组件在发送完成的时候会将这个副本删除。传输层保存着原始的 skb，在当网络对方没有 ack 的时候，还可以重新发送，以实现 TCP 中要求的可靠传输。

（3）第三次拷贝不是必须的，只有当 IP 层发现 skb 大于 MTU 时才需要进行。会再申请额外的 skb，并将原来的 skb 拷贝为多个小的 skb。

**4、回环端口lo**

（1）127.0.0.1 本机网络 IO 不需要经过网卡。即使了把网卡拔了本机网络是否还可以正常使用的。

（2）数据包在内核中是个什么走向，和外网发送相比流程上有啥差别？

本机网络 IO 比跨机 IO 节约了一些开销。发送数据不需要进 RingBuffer 的驱动队列，直接把 skb 传给接收协议栈（经过软中断）。但是在内核其它组件上，可是一点都没少，系统调用、协议栈（传输层、网络层等）、网络设备子系统、邻居子系统整个走了一个遍。连“驱动”程序都走了（虽然对于回环设备来说只是一个纯软件的虚拟出来的东东）。
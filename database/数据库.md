数据库

## 一、etcd

### 2、机制

- Lease 机制：即租约机制（TTL，Time To Live），Etcd 可以为存储的 KV 对设置租约，当租约到期，KV 将失效删除；同时也支持续约，即 KeepAlive。
- Revision 机制：每个 key 带有一个 Revision 属性值，etcd 每进行一次事务对应的全局 Revision 值都会加一，因此每个 key 对应的 Revision 属性值都是全局唯一的。通过比较 Revision 的大小就可以知道进行写操作的顺序。
- 在实现分布式锁时，多个程序同时抢锁，根据 Revision 值大小依次获得锁，可以避免 “羊群效应” （也称 “惊群效应”），实现公平锁。
- Prefix 机制：即前缀机制，也称目录机制。可以根据前缀（目录）获取该目录下所有的 key 及对应的属性（包括 key, value 以及 revision 等）。
- Watch 机制：即监听机制，Watch 机制支持 Watch 某个固定的 key，也支持 Watch 一个目录（前缀机制），当被 Watch 的 key 或目录发生变化，客户端将收到通知。

## 二、redis



## 三、mysql



# 四、分布式锁

### 1、特点

- 互斥性：在任意时刻，只有一个客户端（进程）能持有锁
- 安全性：避免死锁情况，当一个客户端在持有锁期间内，由于意外崩溃而导致锁未能主动解锁，其持有的锁也能够被正确释放，并保证后续其它客户端也能加锁
- 可用性：分布式锁需要有一定的高可用能力，当提供锁的服务节点故障（宕机）时不影响服务运行，避免单点风险，如Redis的集群模式、哨兵模式，ETCD/zookeeper的集群选主能力等保证HA，保证自身持有的数据与故障节点一致。
- 对称性：对同一个锁，加锁和解锁必须是同一个进程，这又称为锁的可重入性。可通过协程id实现

### 2、常见实现

- 通过数据库方式实现：采用乐观锁、悲观锁或者基于主键唯一约束实现
- 基于分布式缓存实现的锁服务： Redis 和基于 Redis 的 RedLock（Redisson提供了参考实现）
- 基于分布式一致性算法实现的锁服务：ZooKeeper、Chubby（google闭源实现）和 Etcd

### 3、redis锁

#### （1）加锁

- 通过key加锁，具有唯一性
- 随机字符串，需保证在足够长时间具有唯一性

#### （2）解锁

- 设置锁过期时间，超时自动删除
- 主动解锁，手动删除

#### （3）样例

```go
// lock
lockSuccess, err := client.SetNX(lockKey, 1, time.Second * 5).Result()
//unlock
unlockSuccess, err := client.Del(lockKey)p.Result()
```

### 4、etcd锁

1. 创建全局唯一key加锁，并设置租约
2. 创建定时任务作为租约的“心跳”
3. 将该key写入etcd，并根据Revision值判断是否获得锁
4. 执行完任务，手动删除锁

```go
* func NewMutex(s *Session, pfx string) *Mutex， 用来新建一个mutex
* func (m *Mutex) Lock(ctx context.Context) error，它会阻塞直到拿到了锁，并且支持通过context来取消获取锁。
* func (m *Mutex) Unlock(ctx context.Context) error，解锁
```

### 5、基于etcd选主

- 发起竞选，未当选leader前，会一直阻塞在Campaign调用

```
创建的key名为：prefix + lease id
Txn：transaction，依靠Txn进行创建key的CAS操作，当key不存在时才会成功创建
如果key已存在，则创建失败；
当key的value与当前value不等时，如果自己为leader，则不用重新执行选举直接设置value；否则报错。
/一直阻塞，直到确认自己的create revision为当前path中最小，从而确认自己当选为leader
```


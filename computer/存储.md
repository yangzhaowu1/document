# 存储
![计算机存储金字塔](vx_images/172763121247106.jpg =600x)
1. CPU寄存器
2. Cache
3. 内存
4. 硬盘等辅助存储设备
5. 鼠标等外接设备
从上至下，访问速度越来越慢，访问时间越来越长，从磁盘到CPU寄存器，上一层均可看做下一层的缓存
# 虚拟内存
向进程屏蔽底层RAM和磁盘，并向进程提供远超物理内存的内存空间
![进程访问数据](vx_images/127034321239775.png =600x)
1. 进程访问数据，若cache未命中
2. 访问虚拟内存，虚拟内存查看页表，判断数据是否已经加载到了物理内存，若未命中
3. 从磁盘加载数据到物理内存，并物理内存地址与虚拟内存地址的映射表
* 物理内存是磁盘存储的缓存层
* 若无虚拟内存，物理内存对所有进程共享，多进程访问物理内存时存在并发问题
* 引入虚拟内存后，进程独享各自的虚拟内存，并发问题降低到线程级别
# 栈和堆
![进程虚拟内存划分](vx_images/587885921236330.png =600x)

* 栈在高地址，从高地址向低地址增长
* 堆在低地址，从低地址向高地址增长
* 栈的内存管理简单，分配比堆上快
* 栈的内存不需要回收，而堆需要
* 栈上的内存访问有更好的局部性
## 堆内存管理
![堆内存管理](vx_images/141790622249964.png =1000x)

* size：内存块大小
* used：是否使用中
* next：下一个内存块地址
* data：实际数据
堆内存最初为一整块，即未分配内存。当申请到来，分配一个内存卡（block），然后用链表串起内存块

* 释放内存：把使用的内存块从链表中取出来，然后标记为未使用
* 分配内存：优先从未使用内存块中分配大小相近的内存块，找不到，再从未分配内存中分配
* 内存碎片问题：将连续未使用的内存块合并
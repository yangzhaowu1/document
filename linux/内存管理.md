# 内存管理
## 进程的内存申请与分配
当我们在终端启动一个程序时，终端进程调用 exec 函数将可执行文件载入内存，此时代码段，数据段，bbs 段，stack 段都通过 mmap 函数映射到内存空间，堆则要根据是否有在堆上申请内存来决定是否映射。

exec 执行之后，此时并未真正开始执行进程，而是将 cpu 控制权交给了动态链接库装载器，由它来将该进程需要的动态链接库装载进内存。之后才开始进程的执行，这个过程可以通过 strace 命令跟踪进程调用的系统函数来分析
内存分配流程
1. 当第一次调用 malloc 申请内存时，通过系统调用 brk 嵌入到内核，首先会进行一次判断，是否有关于堆的 vma，如果没有，则通过 mmap 匿名映射一块内存给堆，并建立 vma 结构，挂到 mm_struct 描述符上的红黑树和链表上。

2. 然后回到用户态，通过内存分配器（ptmaloc，tcmalloc，jemalloc）算法将分配到的内存进行管理，返回给用户所需要的内存。

3. 如果用户态申请大内存时，是直接调用 mmap 分配内存，此时返回给用户态的内存还是虚拟内存，直到第一次访问返回的内存时，才真正进行内存的分配。

5. 其实通过 brk 返回的也是虚拟内存，但是经过内存分配器进行切割分配之后（切割就必须访问内存），全都分配到了物理内存

6. 当进程在用户态通过调用 free 释放内存时，如果这块内存是通过 mmap 分配，则调用 munmap 直接返回给系统。

7. 否则内存是先返回给内存分配器，然后由内存分配器统一返还给系统，这就是为什么当我们调用 free 回收内存之后，再次访问这块内存时，可能不会报错的原因。
## 内存耗尽之后 OOM
OOM（out of memory）即为系统在内存耗尽时的自我拯救措施，他会选择一个进程，将其杀死，释放出内存
### 进程选择方式
 代码位置：oom_kill.c
*判断指标：进程占用的内存、进程运行的时间、进程的优先级、是否为 root 用户进程、子进程个数和占用内存、用户控制参数 oom_adj 
 当产生 oom 之后，函数 select_bad_process 会遍历所有进程，通过之前提到的那些因素，每个进程都会得到一个 oom_score 分数，分数最高，则被选为杀死的进程
### oom_adj
我们可以通过设置 /proc/<pid>/oom_adj 分数来干预系统选择杀死的进程
* oom_adj：最大可以调整为15,最小为-16，如果为-17，则该进程就像买了vip会员一样，不会被系统驱逐杀死了
### overcommit_memory
位置： /proc/sys/vm/overcommit_memory
* 当 overcommit_memory 为0时，则为启发式oom，即当申请的虚拟内存不是很夸张的大于物理内存，则系统允许申请，但是当进程申请的虚拟内存很夸张的大于物理内存，则就会产生 OOM
* 当 overcommit_memory 为1时，则永远都允许 overmemory 内存申请，即不管你多大的虚拟内存申请都允许，但是当系统内存耗尽时，这时就会产生oom
* 当 overcommit_memory 为2时，永远都不能超出某个限定额的内存申请，这个限定额为 swap+RAM* 系数（/proc/sys/vm/overcmmit_ratio，默认50%，可以自己调整），如果这么多资源已经用光，那么后面任何尝试申请内存的行为都会返回错误，这通常意味着此时没法运行任何新程序
## 申请的内存都在哪？
### 共享文件映射
代码段和动态链接库段是映射到内核cache中，也就是说当执行共享文件映射时，文件是先被读取到 cache 中，然后再映射到用户进程空间中
### 私有文件映射段
当进行私有文件映射时，首先是将文件映射到 cache 中，然后如果某个文件对这个文件进行修改，则会从其他内存中分配一块内存先将文件数据拷贝至新分配的内存，然后再在新分配的内存上进行修改，这也就是写时复制

文件映射，则都是将文件映射到 cache 中，然后根据共享还是私有进行不同的操作。

### 私有匿名映射
bbs 段，堆，栈这些都是匿名映射，因为可执行文件中没有相应的段，而且必须是私有映射
在进行匿名私有映射时，并没有占用 cache
### 共享匿名映射
当进行共享匿名映射时，这时是从 cache 中申请内存
## 系统回收内存
### 手动回收
### 自动释放

